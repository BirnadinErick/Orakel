<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Node Creation and Linking</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
            position: relative;
            user-select: none;
        }

        .node {
            position: absolute;
            background-color: red;
            color: white;
            font-size: large;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            padding: 10px 20px;
        }

        .node.active {
            background-color: rgb(0, 255, 247);
        }


        .line {
            position: absolute;
            height: 2px;
            background-color: black;
            /* background: linear-gradient(to right, black, transparent); */
            transform-origin: 0 50%;
            /* Rotate from the left center */
            z-index: -1;
        }


        .cursor {
            width: 1px;
            height: 20px;
            background-color: rgb(255, 123, 0);
            animation: blink 1s step-end infinite;
            margin-left: 0px;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        #inputs {
            z-index: 100;
            position: absolute;
            bottom: 10px;
            width: 90%;
        }

        #promptTxt {
            padding: 10px 10px;
            font-size: 16px;
            background-color: #343434;
            color: #F7FFF7;
            width: 100%;
            border-radius: 5px;
        }

        #fileUpload {
            display: block;
            padding: 10px 5px;
            background-color: #343434;
            color: #f0f0f0;
            margin: 0 0 10px 0;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="inputs">
        <input type="file" name="customFile" id="fileUpload" accept=".txt,.text">
        <button>Process File</button>
        <input placeholder="> type your prompt here" type="text" name="prompt" id="promptTxt" autofocus
            spellcheck="true">
    </div>

    <script>
        let activeNodes = [];
        let nodes = [];
        let isDragging = false;
        let draggedNode = null;
        let offsetX = 0, offsetY = 0;

        function main() {
            // createNode('Generate me 5 interesting names.', 400, 200);
        }

        function createNode(text, x, y, generatedByLLM = false) {
            const node = document.createElement('div');
            node.classList.add('node');
            node.textContent = text;
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            document.body.appendChild(node);

            node.addEventListener('click', () => setActiveNode(node));
            node.addEventListener('contextmenu', (event) => {
                event.preventDefault();  // Prevent the default right-click menu from appearing
                sendToLLM(node)
            });

            node.addEventListener('mousedown', (e) => startDrag(e, node));

            if (activeNodes.length > 0) {
                activeNodes.forEach(activeNode => {
                    createLine(activeNode, node);
                });
            }
            nodes.push(node);

            if (generatedByLLM === false) {
                sendToLLM(node);
                setActiveNode(node);
            }
        }

        function sendToLLM(node) {
            const x = parseInt(node.style.left);
            const y = parseInt(node.style.top);

            let promptForLLM = '[';

            //instead do for i loop
            for (let i = 0; i < activeNodes.length; i++) {
                //if more then one add comma
                promptForLLM += `${activeNodes[i].textContent}`;

                if (i < activeNodes.length - 1) {
                    promptForLLM += ',';
                }
                if ((i === activeNodes.length - 1)) {
                    promptForLLM += ` connected to `;
                }

            }
            promptForLLM += `${node.textContent}]`;

            fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ message: promptForLLM })
            })
                .then(response => response.json())
                .then(data => {

                    const resonesNodeTexts = data['response'];
                    for (let i = 0; i < resonesNodeTexts.length; i++) {
                        createNode(resonesNodeTexts[i], x + i * 200 - 200, y + 100, true);
                    }

                })
                .catch(error => {
                    console.error('Error:', error);
                    // callback('Error: Unable to get a response from the bot.', null);
                });
        }

        function setActiveNode(node) {

            if (isHoldingCtrlOrShift === false) {
                activeNodes.forEach(activeNode => activeNode.classList.remove('active'));
                activeNodes = [];
            }
            activeNodes.push(node);

            node.classList.add('active');
        }

        function createLine(node1, node2) {
            const line = document.createElement('div');
            console.log('line', line);
            line.classList.add('line');
            document.body.appendChild(line);
            updateLine(line, node1, node2);

            // Attach line to nodes for future reference if needed
            node1.lines = node1.lines || [];
            node2.lines = node2.lines || [];
            node1.lines.push({ line, target: node2 });
            node2.lines.push({ line, target: node1 });
        }

        function updateLine(line, node1, node2) {
            const node1Pos = node1.getBoundingClientRect();
            const node2Pos = node2.getBoundingClientRect();

            const x1 = node1Pos.left + node1Pos.width / 2;
            const y1 = node1Pos.top + node1Pos.height / 2;
            const x2 = node2Pos.left + node2Pos.width / 2;
            const y2 = node2Pos.top + node2Pos.height / 2;

            // Calculate distance and angle between the two nodes
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);

            // Set line's position, length, and rotation
            line.style.width = `${distance}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}deg)`;
        }

        function startDrag(event, node) {
            isDragging = true;
            draggedNode = node;
            offsetX = event.clientX - node.getBoundingClientRect().left;
            offsetY = event.clientY - node.getBoundingClientRect().top;
            node.style.cursor = 'grabbing';
            setActiveNode(node);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        function onDrag(event) {
            if (isDragging && draggedNode) {
                const x = event.clientX - offsetX;
                const y = event.clientY - offsetY;
                draggedNode.style.left = `${x}px`;
                draggedNode.style.top = `${y}px`;
                if (draggedNode.lines) {
                    draggedNode.lines.forEach(({ line, target }) => {

                        updateLine(line, draggedNode, target);
                    });
                }
                nodes.forEach(node => {
                    if (node !== draggedNode && node.lines) {
                        node.lines.forEach(({ line, target }) => {
                            if (target === draggedNode) {
                                updateLine(line, node, draggedNode);
                            }
                        });
                    }
                });
            }
        }

        function stopDrag() {
            isDragging = false;
            if (draggedNode) {
                draggedNode.style.cursor = 'pointer';
            }
            draggedNode = null;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        let isHoldingCtrlOrShift = false;

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                const promptTxtBox = document.querySelector("#promptTxt");
                const inputText = promptTxtBox.value;

                let newX = mouseX;
                let newY = mouseY;

                if (activeNodes[0]) {
                    const activeNode = activeNodes[0];
                    newX = parseInt(activeNode.style.left) + 150;
                    newY = parseInt(activeNode.style.top);
                }
                createNode(inputText, newX, newY);
                promptTxtBox.value = '';
            } else if (event.key === 'Control' || event.key === 'Shift') {
                isHoldingCtrlOrShift = true;
            } else {
                return;
            }
        });

        document.addEventListener('keyup', function (event) {
            if (event.key === 'Control' || event.key === 'Shift') {
                isHoldingCtrlOrShift = false;
            }
        });

        let clickedBackgroundPosition = { x: 0, y: 0 };
        let isDraggingBackground = false;
        let offsetXBackground = 0, offsetYBackground = 0;

        document.addEventListener('mousedown', function (event) {
            if (event.target === document.body) {
                activeNodes.forEach(activeNode => activeNode.classList.remove('active'));
                activeNodes = [];

                isDraggingBackground = true;

                clickedBackgroundPosition.x = event.clientX;
                clickedBackgroundPosition.y = event.clientY;
            }
        });

        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', function (event) {
            mouseX = event.clientX;
            mouseY = event.clientY;
            // console.log(`Mouse X: ${mouseX}, Mouse Y: ${mouseY}`);

            if (isDraggingBackground) {
                const diffX = event.clientX - clickedBackgroundPosition.x;
                const diffY = event.clientY - clickedBackgroundPosition.y;
                nodes.forEach(node => {
                    node.style.left = `${parseInt(node.style.left) + diffX}px`;
                    node.style.top = `${parseInt(node.style.top) + diffY}px`;
                    if (node.lines) {
                        node.lines.forEach(({ line, target }) => {
                            updateLine(line, node, target);
                        });
                    }
                });

                // console.log(`event.clientX: ${event.clientX}, event.clientY: ${event.clientY} offsetXBackground: ${offsetXBackground}, offsetYBackground: ${offsetYBackground}`);
                clickedBackgroundPosition.x = event.clientX;
                clickedBackgroundPosition.y = event.clientY;
            }
        });

        document.addEventListener('mouseup', function (event) {
            isDraggingBackground = false;
        });

        main();
    </script>
</body>

</html>